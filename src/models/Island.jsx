/* eslint-disable react/prop-types */
/* eslint-disable react/no-unknown-property */
/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Author: DeathWingS (https://sketchfab.com/DeathWingS)
License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
Source: https://sketchfab.com/3d-models/fantasy-islands-8307a67c99b24a91a09258c12a553e4c
Title: Fantasy Islands
*/

import React, { useRef, useEffect, useState } from 'react'
import { useAnimations, useGLTF } from '@react-three/drei'
import { useFrame, useThree } from '@react-three/fiber'
import fantasyIsland from '../assets/fantasy_islands.glb'
import { a } from '@react-spring/three'
import dragonScean from '../assets/3d/stylized_dragon.glb'


export const Island = ({
    isRotating,
    setIsRotating,
    setCurrentStage,
    ...props
} ) => {
    const {gl,viewport} = useThree() 
    const lastX = useRef(0);
    const lastY = useRef(0); // Add
    const rotationSpeedX = useRef(0); // Add
    const rotationSpeedY = useRef(0); // Add
    const dampingFactor= 0.95;
    const [scale, setScale] = useState(0.009); // Initial scale factor
    const lastScale = useRef(0.01);
    const initialPinchDistance = useRef(null);
    const [isLoading, setIsLoading] = useState(true);
    
    
  const { nodes, materials } = useGLTF(fantasyIsland)
  const islandRef = useRef()
  const [islandPosition, setIslandPosition] = useState([0, 0, 0])
  const [islandScale, setIslandScale] = useState([1, 1, 1])
  const [islandRotation, setIslandRotation] = useState([0, 0, 0])
  const adjustIslandForScreenSize = () => {
    let screenScale = null
    let screenPosition = [0, -1.1, .1]
    let rotation = [0, 0, 0]

    if (window.innerWidth < 768) {
      screenScale = [0.9, 0.9, 0.9]
    } else {
      screenScale = [0.01, 0.01, 0.01]
    }

    setIslandScale(screenScale)
    setIslandPosition(screenPosition)
    setIslandRotation(rotation)
  }
  

  useEffect(() => {
    adjustIslandForScreenSize()
    window.addEventListener('resize', adjustIslandForScreenSize)
    return () => {
      window.removeEventListener('resize', adjustIslandForScreenSize)
    }
  }, [])
  const getPinchDistance = (touches) => {
    const [touch1, touch2] = touches;
    const dx = touch2.clientX - touch1.clientX;
    const dy = touch2.clientY - touch1.clientY;
    return Math.sqrt(dx * dx + dy * dy);
};


  const zoomIn = () => {
    setScale((prevScale) => prevScale * 1.1); // Add
};
const zoomOut = () => {
    setScale((prevScale) => prevScale * 0.9); // Add
};
  
  const handlePointerDown = (e)=>{
    e.stopPropagation()
    e.preventDefault()
    setIsRotating(true);
    const clientX = e.touches?e.touches[0].clientX : e.clientX 
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
    lastX.current=clientX
    lastY.current = clientY; // Add
    
  }
  const handlePointerUp = (e)=>{
    e.stopPropagation()
    e.preventDefault()
    setIsRotating(false);
   
  }
  const handlePointerMove = (e)=>{
    e.stopPropagation()
    e.preventDefault()
    if(isRotating){
        const clientX = e.touches?e.touches[0].clientX : e.clientX 
        const clientY = e.touches ? e.touches[0].clientY : e.clientY; // Add

        const deltaX = (clientX - lastX.current) / viewport.width;
        const deltaY = (clientY - lastY.current) / viewport.height; // Add
  
        islandRef.current.rotation.y += deltaX * 0.01 * Math.PI;
        islandRef.current.rotation.x += deltaY * 0.01 * Math.PI; // Add
  
        lastX.current = clientX;
        lastY.current = clientY; // Add
  
        rotationSpeedX.current = deltaX * 0.01 * Math.PI;
        rotationSpeedY.current = deltaY * 0.01 * Math.PI; // Add
    }
   
  }

  const handleKeyDown = (event) => {
    if (event.key === "ArrowLeft") {
        if (!isRotating) setIsRotating(true);
        islandRef.current.rotation.y += 0.005 * Math.PI;
        rotationSpeedX.current = 0.007;
      } else if (event.key === "ArrowRight") {
        if (!isRotating) setIsRotating(true);
        islandRef.current.rotation.y -= 0.005 * Math.PI;
        rotationSpeedX.current = -0.007;
      } else if (event.key === "ArrowUp") { // Add
        if (!isRotating) setIsRotating(true);
        islandRef.current.rotation.x += 0.005 * Math.PI;
        rotationSpeedY.current = 0.007;
      } else if (event.key === "ArrowDown") { // Add
        if (!isRotating) setIsRotating(true);
        islandRef.current.rotation.x -= 0.005 * Math.PI;
        rotationSpeedY.current = -0.007;
      } else if (event.key === "+") {
        zoomIn();
      } else if (event.key === "-") {
        zoomOut();
      }
  };

  // Handle keyup events
  const handleKeyUp = (event) => {
    if (event.key === "ArrowLeft" || event.key === "ArrowRight"  || event.key === "ArrowUp" || event.key === "ArrowDown") {
      setIsRotating(false);
    }
  };
  const handleTouchStart = (e) => {
    e.stopPropagation();
    e.preventDefault();
    setIsRotating(true);
    if (e.touches.length === 2) {
        initialPinchDistance.current = getPinchDistance(e.touches);  // Add
        lastScale.current = scale;
    } else {
        handlePointerDown(e);  // Add
    }
  
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY; // Add
    lastX.current = clientX;
    lastY.current = clientY; // Add
  }
  
  const handleTouchEnd = (e) => {
    e.stopPropagation();
    e.preventDefault();
    setIsRotating(false);
    initialPinchDistance.current = null;  // Add
  }
  
  const handleTouchMove = (e) => {
    e.stopPropagation();
    e.preventDefault();
  
    if (e.touches.length === 2) {
        const newPinchDistance = getPinchDistance(e.touches);
        if (initialPinchDistance.current) {
          const scaleChange = newPinchDistance / initialPinchDistance.current;
          setScale(lastScale.current * scaleChange); // Apply scale change relative to the last scale
        }
      } else {
        handlePointerMove(e);  // Add
      }
  }

  useEffect(()=>{
    const canvas = gl.domElement;
    canvas.addEventListener('pointerdown',handlePointerDown)
    canvas.addEventListener('pointerup',handlePointerUp)
    canvas.addEventListener('pointermove',handlePointerMove)
    window.addEventListener("keydown", handleKeyDown);
    window.addEventListener("keyup", handleKeyUp);
    canvas.addEventListener("touchstart", handleTouchStart);
    canvas.addEventListener("touchend", handleTouchEnd);
    canvas.addEventListener("touchmove", handleTouchMove);
    return()=>{
        canvas.removeEventListener('pointerdown',handlePointerDown)
        canvas.removeEventListener('pointerup',handlePointerUp)
        canvas.removeEventListener('pointermove',handlePointerMove)
        window.removeEventListener("keydown", handleKeyDown);
        window.removeEventListener("keyup", handleKeyUp);
        canvas.removeEventListener("touchstart", handleTouchStart);
        canvas.removeEventListener("touchend", handleTouchEnd);
        canvas.removeEventListener("touchmove", handleTouchMove);
    }

  },[gl,handlePointerDown, handlePointerUp, handlePointerMove])


  useFrame(()=>{
    if (!isRotating) {
        rotationSpeedX.current *= dampingFactor;
        rotationSpeedY.current *= dampingFactor; // Add
        if (Math.abs(rotationSpeedX.current) < 0.001) {
          rotationSpeedX.current = 0;
        }
        if (Math.abs(rotationSpeedY.current) < 0.001) { // Add
          rotationSpeedY.current = 0;
        }
        islandRef.current.rotation.y += rotationSpeedX.current;
        islandRef.current.rotation.x += rotationSpeedY.current; // Add
      }
    else{
        const rotationX = islandRef.current.rotation.x;
      const rotationY = islandRef.current.rotation.y;
      const normalizedRotationY =
        ((rotationY % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);
      const normalizedRotationX =
        ((rotationX % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);

      // Set the current stage based on the island's orientation
      if (
  normalizedRotationY >= 4.5 &&
  normalizedRotationY <= 5 
  
) {
  setCurrentStage(4);
} else if (
  normalizedRotationY >= 2 &&
  normalizedRotationY <= 3 
 
) {
  setCurrentStage(3);
} else if (
  normalizedRotationY >= 3.25 &&
  normalizedRotationY <= 3.75 
  
) {
  setCurrentStage(2);
} else if (
  normalizedRotationY >= 0 &&
  normalizedRotationY <= .5 
  
) {
  setCurrentStage(1);
} else {
  setCurrentStage(null);
}

    }
    islandRef.current.scale.set(scale, scale, scale);
  })
  const ref = useRef()
  const {scene ,animations} = useGLTF(dragonScean)
  const{actions }= useAnimations (animations,ref)
  useEffect(()=>{
      actions['Wing flaps'].play()
  },[actions]) 

  return (
    <>
    <a.group {...props} dispose={null} ref={islandRef} position={islandPosition} scale={islandScale} rotation={islandRotation}>
     
    <group rotation={[ .7, 0, 0]} position={[-1, 20, -100]} ref={ref}>
                 <mesh scale={60} >
                    <primitive object={scene} />
                 </mesh>
          </group>
      <group rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]}>

       
          <group name='waterhouse'>
            
              <group position={[138.971, 37.076, 11.063]} rotation={[0, 1.236, 0]}>
                <mesh
                  castShadow
                  receiveShadow
                  geometry={nodes.AguatorreShape_2_0.geometry}
                  material={materials.AguatorreShape}
                />
                <mesh
                  castShadow
                  receiveShadow
                  geometry={nodes.AguatorreShape_2_0_1.geometry}
                  material={materials.AguatorreShape}
                />
                    
              </group>
              <group position={[152.004, 0, 8.371]} rotation={[0, 1.236, 0]}>
                <mesh
                  castShadow
                  receiveShadow
                  geometry={nodes.IslaAShape_4_0.geometry}
                  material={materials.IslaAShape}
                />
                <mesh
                  castShadow
                  receiveShadow
                  geometry={nodes.IslaAShape_4_0_1.geometry}
                  material={materials.IslaAShape}
                />
                    
              </group>
                
            
              <group position={[152.004, 0, 8.371]} rotation={[0, 1.236, 0]}>
                <mesh
                  castShadow
                  receiveShadow
                  geometry={nodes.TorreShape_6_0.geometry}
                  material={materials.TorreShape}
                />
                <mesh
                  castShadow
                  receiveShadow
                  geometry={nodes.TorreShape_6_0_1.geometry}
                  material={materials.TorreShape}
                />
              </group>
          </group>
          
          <group position={[102.599, 0.433, 23.273]} rotation={[0, Math.PI / 2, 0]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.bridgeShape_8_0.geometry}
              material={materials.bridgeShape}
            />
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.bridgeShape_8_0_1.geometry}
              material={materials.bridgeShape}
            />
          </group>
          <group name='golemisland' position={[163.113, 2.555, -330.589]} rotation={[0, -Math.PI / 2, 0]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.IslaGolemShape_10_0.geometry}
              material={materials.IslaGolemShape}
            />
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.IslaGolemShape_10_0_1.geometry}
              material={materials.IslaGolemShape}
            />
          </group>
          <group position={[-248.354, 262.738, -241.747]} rotation={[0, -0.647, 0]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.IslandHouse_2Shape_12_0.geometry}
              material={materials.IslandHouse_2Shape}
            />
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.IslandHouse_2Shape_12_0_1.geometry}
              material={materials.IslandHouse_2Shape}
            />
          </group>
          <group name='houseisland' position={[-48.543, -10.264, 74.775]} rotation={[0, -0.647, 0]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.IslandHouse_1Shape_14_0.geometry}
              material={materials.IslandHouse_1Shape}
            />
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.IslandHouse_1Shape_14_0_1.geometry}
              material={materials.IslandHouse_1Shape}
            />
          </group>
          <group position={[-58.218, -28.312, -143.23]}>
            <group position={[-112.799, 28.312, -100.559]} rotation={[0, -0.452, 0]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.MimicShape_18_0.geometry}
                material={materials.MimicShape}
              />
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.MimicShape_18_0_1.geometry}
                material={materials.MimicShape}
              />
            </group>
            <group position={[-109.967, 33.128, -107.397]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.dragonShape_20_0.geometry}
                material={materials.dragonShape}
              />
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.dragonShape_20_0_1.geometry}
                material={materials.dragonShape}
              />
            </group>
            <group name='dragon island' position={[-109.967, 33.128, -107.397]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.dragonShape_20_0_2.geometry}
                material={materials.dragonShape}
              />
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.dragonShape_20_0_3.geometry}
                material={materials.dragonShape}
              />
            </group>
            <group position={[-112.799, 28.312, -100.559]} rotation={[0, -0.452, 0]}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.MimicShape_18_0_2.geometry}
                material={materials.MimicShape}
              />
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.MimicShape_18_0_3.geometry}
                material={materials.MimicShape}
              />
            </group>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.IslaDragonShape_16_0.geometry}
              material={materials.IslaDragonShape}
            />
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.IslaDragonShape_16_0_1.geometry}
              material={materials.IslaDragonShape}
            />
          </group>
          
          <group position={[-81.326, 315.806, -241.747]} rotation={[-Math.PI, 0.997, Math.PI]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.IslandHouseShape_22_0.geometry}
              material={materials.IslandHouseShape}
            />
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.IslandHouseShape_22_0_1.geometry}
              material={materials.IslandHouseShape}
            />
          </group>
          <group position={[-81.326, 315.806, -241.747]} rotation={[-Math.PI, 0.997, Math.PI]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.IslandHouseShape_22_0_2.geometry}
              material={materials.IslandHouseShape}
            />
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.IslandHouseShape_22_0_3.geometry}
              material={materials.IslandHouseShape}
            />
          </group>
        </group>
      </group>
    </a.group>
    </>
  )
}

useGLTF.preload(fantasyIsland)
